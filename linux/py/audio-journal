#!/usr/bin/env python3

import argparse
import asyncio
import boto3
import eyed3
import hashlib
import itertools
import json
import logging
import mimetypes
import os
import pathlib
import queue
import re
import shutil
import signal
import socket
import subprocess
import sys
import tempfile
import threading
import urllib

from enum import Enum
from base64 import b64encode
from datetime import date, time, datetime

import tkinter as tk
from tkinter import ttk

s3 = boto3.resource("s3")
s3_client = boto3.client("s3")

def render_duration(secs):
    s = ""
    if secs >= 60 * 60 * 24:
        s += f"{secs // (60 * 60 * 24)}d"
        secs %= 60 * 60 * 24
    if secs >= 60 * 60:
        s += f"{secs // (60 * 60)}h"
        secs %= 60 * 60
    if secs >= 60:
        s += f"{secs // 60}m"
        secs %= 60
    if secs > 0:
        s += f"{secs}s"
    return s

logger = None
def setup_logger(level):
    l = logging.getLogger("audio-journal")
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(
        fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

def parse_args():
    parser = argparse.ArgumentParser(
            description="Audio Journal command line interface",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    subparsers = parser.add_subparsers(help="sub-commands", dest='command', required=True)

    home = pathlib.Path.home()
    default_cache = home / ".cache" / "audio-journal"
    config = home / ".config" / "audio-journal"

    parser.add_argument("--log", default="INFO", help="set log level")
    parser.add_argument("--cache", default=default_cache, help="cache")
    parser.add_argument("--config", default=config, help="config")

    list_cmd = subparsers.add_parser("list", help="list sounds")
    list_cmd.add_argument("profile", metavar="PROFILE", nargs="*")

    record = subparsers.add_parser("record", help="record track")
    record.add_argument("--loop", action="store_true", help="continuously record and process sounds")
    record.add_argument("profile", metavar="PROFILE", nargs="?")

    gui = subparsers.add_parser("gui", help="run the GUI")
    gui.add_argument("profile", metavar="PROFILE", nargs="*")

    return parser.parse_args()

class Cache:
    def __init__(self, path):
        self.path = path

    def _lazy_init(self):
        if not self.path.exists():
            logger.info(f"creating cache: {self.path}")
            self.path.mkdir(parents=True)

    def _path(self, parts):
        m = hashlib.sha256()
        for p in parts:
            m.update(bytes(p, "UTF-8"))
        return self.path / m.hexdigest()

    class Object:
        def __init__(self, cache, keys):
            self.cache = cache
            self.path = self.cache._path(parts=keys)
            self.keys = keys

        def exists(self):
            return self.path.exists()

        def get_string(self):
            return self.path.read_text() if self.exists() else None

        def put_string(self, s):
            self.cache._lazy_init()
            logger.debug(f"writing cached object: {self.path}")
            self.path.write_text(s)

        def get_json(self):
            s = self.get_string()
            return s and json.loads(s)

        def put_json(self, o):
            self.put_string(json.dumps(o))

        def json(self, f):
            j = self.get_json()
            if j is None:
                j = f()
                self.put_json(j)
            return j

    class NullObject:
        def exists(self):
            return None
        def get_string(self):
            return None
        def get_json(self):
            return None

    def __call__(self, *keys):
        if self.path:
            return Cache.Object(cache=self, keys=keys)
        else:
            return Cache.NullObject()

cache = None
def setup_cache(args):
    return Cache(path=args.cache)

def lenient_datetime_parse(s):
    try:
        d = date.fromisoformat(s)
        tz = datetime.now().astimezone().tzinfo
        return datetime.combine(d, time(0, 0, 0), tz)
    except ValueError:
        pass
    try:
        return datetime.fromisoformat(s)
    except ValueError:
        t = re.sub(r"^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}).\d*([+-]\d{2}:\d{2})", r"\1\2", s)
        return datetime.fromisoformat(t)

class Sound:
    def __init__(self, title, artist, composer, length, url, sha1, datetime, filename, mimetype):
        self.title = title
        self.artist = artist
        self.composer = composer
        self.length = length
        self.url = url
        self.sha1 = sha1
        self.datetime = datetime
        self.filename = filename
        self.mimetype = mimetype
        self.local = None

    def from_json(j):
        return Sound(
                title = j["title"],
                artist = j["artist"],
                composer = j["composer"],
                length = j["length"],
                url = j["url"],
                sha1 = j["sha1"],
                filename = j["filename"],
                mimetype = j.get("mimetype"),
                datetime = lenient_datetime_parse(j["date"]))

    def to_json(self):
        return {
            "title": self.title,
            "artist": self.artist,
            "composer": self.composer,
            "length": self.length,
            "url": self.url,
            "sha1": self.sha1,
            "filename": self.filename,
            "mimetype": self.mimetype,
            "date": self.datetime.isoformat()
        }

class Profile:
    def __init__(self, filename, bucket, local, title, artist, composer, prefix):
        self.filename = filename
        self.bucket = bucket
        self.local = local
        self.title = title
        self.artist = artist
        self.composer = composer
        self.prefix = prefix

    def default():
        return Profile(
                filename = "%Y-%m-%dT%H:%M:%S%z.mp3",
                title = "Session @ %Y-%m-%dT%H:%M:%S%z",
                local = pathlib.Path.home() / "audio-journal",
                bucket = None,
                artist = None,
                composer = None,
                prefix = None)

    def from_json(j):
        return Profile(
                filename = j["filename"],
                bucket = j.get("bucket"),
                local = j.get("local"),
                title = j.get("title"),
                artist = j.get("artist"),
                composer = j.get("composer"),
                prefix = j.get("prefix"))

    def __repr__(self):
        return f"Profile(prefix={self.prefix},filename={self.filename},bucket={self.bucket},local={self.local},title={self.title},artist={self.artist},composer={self.composer})"

def resolve_profile(args, profile=None):
    d = pathlib.Path(args.config) / "profiles"

    if profile is None:
        f = d / "default"
        if not f.exists():
            return Profile.default()
    else:
        f = d / profile

    if f.exists():
        return Profile.from_json(json.loads(f.read_text()))
    else:
        raise RuntimeError(f"can not load profile: {f}")

def load_sounds(args):
    ss = set()
    if len(args.profile) == 0:
        ps = [ resolve_profile(args, None) ]
    else:
        ps = [ resolve_profile(args, p) for p in args.profile ]
    logger.debug(f"listing sounds: {ps}")

    for p in ps:
        if p.bucket is not None:
            b = s3.Bucket(p.bucket)

            if len(args.prefix) == 0:
                i = b.objects.all()
            else:
                i = itertools.chain(*[b.objects.filter(Prefix=p) for p in args.prefix])

            for o in i:
                if not o.key.endswith(".json"):
                    continue

                j = cache(b.name, o.key, o.e_tag).json(lambda: json.loads(o.get()["Body"].read()))
                s = Sound.from_json(j)
                ss.add(s)

        if p.local is not None:
            def load(f):
                s = Sound.from_json(json.loads(f.read_text()))
                s.local = f.parent / s.filename
                ss.add(s)

            l = pathlib.Path(p.local).expanduser()
            if p.prefix is not None:
                l /= p.prefix

            def go(d):
                for f in d.iterdir():
                    if f.is_dir():
                        go(f)
                    else:
                        if f.name.endswith(".json"):
                            load(f)
            go(l)

    return ss

def list_cmd(args):
    ss = load_sounds(args)

    for s in sorted(ss, key=lambda s: s.datetime):
        if s.local is not None:
            print(s.local)
        elif s.url is not None:
            print(s.url)

def compute_sha1_md5(fn):
    with open(fn, mode="rb") as f:
        sha1 = hashlib.sha1()
        md5 = hashlib.md5()
        while True:
            bs = f.read(4096)
            if len(bs) == 0: break
            sha1.update(bs)
            md5.update(bs)
        return (sha1.digest(), md5.digest())

def postprocess(profile, fn):
    b = None
    if profile.bucket is not None:
        b = s3.Bucket(profile.bucket)
        bl = s3_client.get_bucket_location(Bucket=b.name)["LocationConstraint"]

    date = datetime.strptime(fn.name, profile.filename)
    af = eyed3.load(fn)
    af.tag = eyed3.id3.Tag()
    af.tag.recording_date = date.date().isoformat()
    if profile.artist is not None:
        af.tag.artist = profile.artist
    if profile.title is not None:
        af.tag.title = date.strftime(profile.title)
    if profile.composer is not None:
        af.tag.composer = profile.composer
    af.tag.save()
    duration = af.info.time_secs
    mimetype, _ = mimetypes.guess_type(fn)
    sha1, md5 = compute_sha1_md5(fn)

    if b is not None:
        if profile.prefix is not None:
            key = f"{profile.prefix}/{fn.name}"
        else:
            key = fn.name

        url = "https://%s.s3.%s.amazonaws.com/%s" % (
                b.name,
                bl,
                urllib.parse.quote(key, safe="~()*!.'/"))
    else:
        url = None

    s = Sound(
            title = af.tag.title,
            artist = af.tag.artist,
            composer = af.tag.composer,
            length = duration,
            url = url,
            sha1 = sha1.hex(),
            datetime = date,
            filename = fn.name,
            mimetype = mimetype)

    metadata = bytes(json.dumps(s.to_json()), "UTF-8")

    if b is not None:
        logger.debug(f"uploading sound file: s3://{b.name}/{key}")
        with open(fn, mode="rb") as f:
            b.put_object(
                    Key = key,
                    ACL = "public-read",
                    Body = f,
                    ContentType = mimetype,
                    ContentMD5 = str(b64encode(md5), "UTF-8"))

        if profile.prefix is not None:
            key = f"{profile.prefix}/{fn.stem}.json"
        else:
            key = f"{fn.stem}.json"

        md5 = hashlib.md5()
        md5.update(metadata)
        md5 = md5.digest()
        logger.debug(f"uploading sound metadata: s3://{b.name}/{key}")
        b.put_object(
                Key = key,
                ACL = "public-read",
                Body = metadata,
                ContentType = "application/json",
                ContentMD5 = str(b64encode(md5), "UTF-8"))

    if profile.local is not None:
        d = pathlib.Path(profile.local).expanduser()
        if profile.prefix is not None:
            d = d / pathlib.Path(profile.prefix)

        if not d.exists():
            d.mkdir(parents=True)

        target = d / fn.name
        logger.debug(f"copying local sound file: {target}")
        shutil.copy(fn, target)
        s.local = target

        target = d / f"{fn.stem}.json"
        logger.debug(f"writing local sound metadata: {target}")
        target.write_bytes(metadata)

    if logger.level <= logging.DEBUG:
        logger.debug(f"successfully processed sound: filename={s.filename} date={s.datetime} sha1={s.sha1} length={s.length} mimetype={s.mimetype} url={s.url} local={s.local}")
    else:
        logger.info(f"successfully processed: {s.title}")

    return s

class Recorder:
    class State(Enum):
        NOT_RUNNING = 0
        WAITING = 1
        RECORDING = 2
        SILENCE = 3
        STOPPING = 4

    class Update:
        def __init__(self, state, peak, rms):
            self.state = state
            self.peak = peak
            self.rms = rms

    def __init__(self):
        self.state_listeners = set()
        self.sound_listeners = set()
        self.process = None
        self.pps = set()

    def add_state_listener(self, f):
        self.state_listeners.add(f)

    def add_sound_listener(self, f):
        self.sound_listeners.add(f)

    async def record(self, profile):
        if self.process is not None:
            raise NotImplementedError

        r, w = socket.socketpair(socket.AF_UNIX, socket.SOCK_DGRAM)
        w.set_inheritable(True)

        class Server:
            def connection_made(self, transport):
                pass

            def datagram_received(server, data, addr):
                state = Recorder.State(data[0])
                rms = int.from_bytes(data[1:2], byteorder=sys.byteorder)
                peak = int.from_bytes(data[3:5], byteorder=sys.byteorder)
                u = Recorder.Update(state=state, rms=rms, peak=peak)
                for f in self.state_listeners:
                    f(u)

        wd = tempfile.TemporaryDirectory(prefix="audio-journal-")
        logger.debug(f"recording workdir: {wd.name}")

        trec = os.environ.get("TREC", default="trec")
        args = []
        if len(self.state_listeners) > 0:
            loop = asyncio.get_running_loop()
            transport, protocol = await loop.create_datagram_endpoint(lambda: Server(), sock=r)
            args.extend([ "-M", str(w.fileno()), "-m", str(10) ])
        args.append(f"{wd.name}/{profile.filename}")
        self.process = await asyncio.create_subprocess_exec(trec, *args, close_fds=False)
        w.close()

        ec = await self.process.wait()
        if ec != 0:
            raise RuntimeError(f"{trec} terminated with non-zero exit code: {ec}")
        self.process = None

        fs = list(pathlib.Path(wd.name).iterdir())
        if len(fs) == 0:
            return None
        elif len(fs) == 1:
            [fn] = fs
        else:
            raise RuntimeError(f"{trec} produced unexpected files")

        def wrapper(wd):
            with wd:
                s = postprocess(profile, fn)
                for f in self.sound_listeners:
                    f(s)
                return s
        pp = asyncio.create_task(asyncio.to_thread(wrapper, wd))
        self.pps.add(pp)
        pp.add_done_callback(self.pps.remove)
        return pp

    async def wait(self):
        if len(self.pps) > 0:
            await asyncio.wait(self.pps)

    def stop(self):
        if self.process is not None:
            self.process.terminate()

def record_cmd(args):
    profile = resolve_profile(args, args.profile)
    logger.debug(f"recording using profile: {profile}")

    r = Recorder()
    if args.loop:
        async def record_loop():
            running = True
            def stop():
                nonlocal running
                running = False
                r.stop()
            asyncio.get_running_loop().add_signal_handler(signal.SIGINT, stop)
            asyncio.get_running_loop().add_signal_handler(signal.SIGTERM, stop)
            while running:
                await r.record(profile)
            await r.wait()
        asyncio.run(record_loop())
    else:
        async def oneshot():
            asyncio.get_running_loop().add_signal_handler(signal.SIGINT, r.stop)
            asyncio.get_running_loop().add_signal_handler(signal.SIGTERM, r.stop)
            pp = await r.record(profile)
            if pp is not None:
                await pp
        asyncio.run(oneshot())

class GUI:
    def __init__(self, args):
        self.running = True
        self.args = args
        self.recorder = Recorder()

        self.root = tk.Tk()
        self.root.title("audio-journal")

        self.sounds_view = ttk.Treeview(self.root, columns=("duration",), selectmode="browse")
        self.sounds_view.heading("duration", text="Duration")
        self.sounds_view.grid(row=0, column=0, columnspan=3, sticky=(tk.N, tk.S, tk.E, tk.W))

        self.sounds = set()
        for s in sorted(load_sounds(args), key=lambda s: s.datetime):
            self.insert_sound(s)

        self.status = ttk.Label(self.root, text='00:00:00.000', font="TkFixedFont", anchor="center", relief="sunken")
        self.status.grid(row=1, rowspan=2, column=0, sticky=(tk.N, tk.S, tk.E, tk.W))

        self.peak = ttk.Progressbar(self.root, orient=tk.HORIZONTAL, mode="determinate", maximum=32767)
        self.peak.grid(row=1, column=1, sticky=(tk.N, tk.S, tk.E, tk.W))
        self.rms = ttk.Progressbar(self.root, orient=tk.HORIZONTAL, mode="determinate", maximum=32767)
        self.rms.grid(row=2, column=1, sticky=(tk.N, tk.S, tk.E, tk.W))

        self.profiles = tk.Listbox(self.root, height=10)
        self.profiles.grid(row=1, rowspan=2, column=2, sticky=(tk.N, tk.S, tk.E, tk.W))

        self.root.columnconfigure(0, weight=1)
        self.root.columnconfigure(1, weight=5)
        self.root.columnconfigure(2, weight=2)
        self.root.rowconfigure(0, weight=100)
        self.root.rowconfigure(1, weight=1)
        self.root.rowconfigure(2, weight=1)

        self.root.bind("<Escape>", lambda e: self.stop())

        self.update_queue = queue.Queue()
        def generate_state_update_event(update):
            self.update_queue.put(update, block=False)
            self.root.event_generate("<<RecordingStateUpdate>>")
        self.recorder.add_state_listener(generate_state_update_event)
        self.root.bind("<<RecordingStateUpdate>>", self.handle_recording_state_update);

        self.sound_queue = queue.Queue()
        def generate_new_sound_event(s):
            self.sound_queue.put(s)
            self.root.event_generate("<<NewSound>>")
        self.recorder.add_sound_listener(generate_new_sound_event)
        self.root.bind("<<NewSound>>", self.handle_new_sounds);

    def handle_recording_state_update(self, *args):
        update = None
        try:
            while True:
                update = self.update_queue.get(block=False)
        except queue.Empty:
            pass

        self.rms["value"] = update.rms
        self.peak["value"] = update.peak

        if update.state == Recorder.State.WAITING:
            self.status["background"] = "green"
        elif update.state == Recorder.State.RECORDING:
            self.status["background"] = "red"
        elif update.state == Recorder.State.SILENCE:
            self.status["background"] = "dark red"

    def handle_new_sounds(self, *args):
        try:
            while True:
                self.insert_sound(self.sound_queue.get(block=False))
        except queue.Empty:
            pass

    def insert_sound(self, s):
        self.sounds.add(s)
        self.sounds_view.insert("", "end", hash(s), text=s.title, values=(render_duration(round(s.length)),))
        self.sounds_view.see(hash(s))

    def stop(self):
        self.recorder.stop()
        self.running = False
        self.root.destroy()

    def run(self):
        profile = resolve_profile(self.args, None)

        async def record_loop():
            while self.running:
                await self.recorder.record(profile)
            await self.recorder.wait()

        t = threading.Thread(target=lambda: asyncio.run(record_loop()))
        t.start()
        self.root.mainloop()
        t.join()

if __name__ == "__main__":
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug(f"args: {args}")

    cache = setup_cache(args)

    if args.command == "list":
        list_cmd(args)
    elif args.command == "record":
        record_cmd(args)
    elif args.command == "gui":
        GUI(args).run()
    else:
        raise NotImplementedError(f"subcommand {args.command}")
