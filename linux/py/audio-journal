#!/usr/bin/env python3

import argparse
import boto3
import eyed3
import hashlib
import itertools
import json
import logging
import mimetypes
import pathlib
import re
import subprocess
import tempfile
import urllib
import os

from base64 import b64encode
from datetime import date, time, datetime

s3 = boto3.resource("s3")
s3_client = boto3.client("s3")

logger = None
def setup_logger(level):
    l = logging.getLogger("audio-journal")
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(
        fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

def parse_args():
    parser = argparse.ArgumentParser(
            description="Audio Journal command line interface",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    subparsers = parser.add_subparsers(help="sub-commands", dest='command', required=True)

    home = pathlib.Path.home()
    default_cache = home / ".cache" / "audio-journal"

    parser.add_argument("--log", default="WARN", help="set log level")
    parser.add_argument("--bucket", default="rootmos-sounds", help="S3 bucket")
    parser.add_argument("--cache", default=default_cache, help="cache")

    list_cmd = subparsers.add_parser("list", help="list sounds")
    list_cmd.add_argument("prefix", metavar="PREFIX", nargs="*")

    record = subparsers.add_parser("record", help="record track")
    record.add_argument("--prefix", help="prefix")

    return parser.parse_args()

class Cache:
    def __init__(self, path):
        self.path = path

    def _lazy_init(self):
        if not self.path.exists():
            logger.info(f"creating cache: {self.path}")
            self.path.mkdir(parents=True)

    def _path(self, parts):
        m = hashlib.sha256()
        for p in parts:
            m.update(bytes(p, "UTF-8"))
        return self.path / m.hexdigest()

    class Object:
        def __init__(self, cache, keys):
            self.cache = cache
            self.path = self.cache._path(parts=keys)
            self.keys = keys

        def exists(self):
            return self.path.exists()

        def get_string(self):
            return self.path.read_text() if self.exists() else None

        def put_string(self, s):
            self.cache._lazy_init()
            logger.debug(f"writing cached object: {self.path}")
            self.path.write_text(s)

        def get_json(self):
            s = self.get_string()
            return s and json.loads(s)

        def put_json(self, o):
            self.put_string(json.dumps(o))

        def json(self, f):
            j = self.get_json()
            if j is None:
                j = f()
                self.put_json(j)
            return j

    class NullObject:
        def exists(self):
            return None
        def get_string(self):
            return None
        def get_json(self):
            return None

    def __call__(self, *keys):
        if self.path:
            return Cache.Object(cache=self, keys=keys)
        else:
            return Cache.NullObject()

cache = None
def setup_cache(args):
    return Cache(path=args.cache)

def lenient_datetime_parse(s):
    try:
        d = date.fromisoformat(s)
        tz = datetime.now().astimezone().tzinfo
        return datetime.combine(d, time(0, 0, 0), tz)
    except ValueError:
        pass
    try:
        return datetime.fromisoformat(s)
    except ValueError:
        t = re.sub(r"^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}).\d*([+-]\d{2}:\d{2})", r"\1\2", s)
        return datetime.fromisoformat(t)

class Sound:
    def __init__(self, title, artist, composer, length, url, sha1, datetime, filename, mimetype):
        self.title = title
        self.artist = artist
        self.composer = composer
        self.length = length
        self.url = url
        self.sha1 = sha1
        self.datetime = datetime
        self.filename = filename
        self.mimetype = mimetype

    def from_json(j):
        return Sound(
                title = j["title"],
                artist = j["artist"],
                composer = j["composer"],
                length = j["length"],
                url = j["url"],
                sha1 = j["sha1"],
                filename = j["filename"],
                mimetype = j.get("mimetype"),
                datetime = lenient_datetime_parse(j["date"]))

    def to_json(self):
        return {
            "title": self.title,
            "artist": self.artist,
            "composer": self.composer,
            "length": self.length,
            "url": self.url,
            "sha1": self.sha1,
            "filename": self.filename,
            "mimetype": self.mimetype,
            "date": self.datetime.isoformat()
        }

def load_sounds(args):
    b = s3.Bucket(args.bucket)

    if len(args.prefix) == 0:
        i = b.objects.all()
    else:
        i = itertools.chain(*[b.objects.filter(Prefix=p) for p in args.prefix])

    ss = set()
    for o in i:
        if not o.key.endswith(".json"):
            continue

        j = cache(b.name, o.key, o.e_tag).json(lambda: json.loads(o.get()["Body"].read()))
        s = Sound.from_json(j)
        ss.add(s)

    return ss

def list_cmd(args):
    ss = load_sounds(args)

    for s in sorted(ss, key=lambda s: s.datetime):
        print(s.url)

def compute_sha1_md5(fn):
    with open(fn, mode="rb") as f:
        sha1 = hashlib.sha1()
        md5 = hashlib.md5()
        while True:
            bs = f.read(4096)
            if len(bs) == 0: break
            sha1.update(bs)
            md5.update(bs)
        return (sha1.digest(), md5.digest())

def record_cmd(args):
    fn_template = "%Y-%m-%dT%H:%M:%S%z.mp3"
    title_template = "Session @ %Y-%m-%dT%H:%M:%S%z"
    artist = "rootmos"
    composer = "Gustav Behm"

    def postprocess(wd):
        b = s3.Bucket(args.bucket)
        bl = s3_client.get_bucket_location(Bucket=b.name)["LocationConstraint"]
        p = pathlib.Path(wd.name)
        for fn in p.iterdir():
            d = datetime.strptime(fn.name, fn_template)
            af = eyed3.load(fn)
            af.tag = eyed3.id3.Tag()
            af.tag.artist = artist
            af.tag.title = d.strftime(title_template)
            af.tag.composer = composer
            af.tag.recording_date = d.date().isoformat()
            af.tag.save()
            duration = af.info.time_secs
            mimetype, _ = mimetypes.guess_type(fn)
            sha1, md5 = compute_sha1_md5(fn)

            if args.prefix is not None:
                key = f"{args.prefix}/{fn.name}"
            else:
                key = fn.name

            with open(fn, mode="rb") as f:
                b.put_object(
                        Key = key,
                        ACL = "public-read",
                        Body = f,
                        ContentType = mimetype,
                        ContentMD5 = str(b64encode(md5), "UTF-8"))

            url = "https://%s.s3.%s.amazonaws.com/%s" % (
                    b.name,
                    bl,
                    urllib.parse.quote(key, safe="~()*!.'/"))

            s = Sound(
                    title = af.tag.title,
                    artist = af.tag.artist,
                    composer = af.tag.composer,
                    length = duration,
                    url = url,
                    sha1 = sha1.hex(),
                    datetime = d,
                    filename = fn.name,
                    mimetype = mimetype)

            if args.prefix is not None:
                key = f"{args.prefix}/{fn.stem}.json"
            else:
                key = f"{fn.stem}.json"

            m = bytes(json.dumps(s.to_json()), "UTF-8")
            md5 = hashlib.md5()
            md5.update(m)
            md5 = md5.digest()
            b.put_object(
                        Key = key,
                        ACL = "public-read",
                        Body = m,
                        ContentType = "application/json",
                        ContentMD5 = str(b64encode(md5), "UTF-8"))

            logger.debug(f"processed: filename={fn.name} date={d} sha1={sha1.hex()} md5={md5.hex()} length={duration} mimetype={mimetype} url={url}")

    while True:
        wd = tempfile.TemporaryDirectory(prefix="audio-journal-")
        logger.debug(f"workdir: {wd.name}")
        trec = os.environ.get("TREC", default="trec")
        subprocess.run([trec, f"{wd.name}/{fn_template}"], check=True)
        postprocess(wd)

if __name__ == "__main__":
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug(f"args: {args}")

    cache = setup_cache(args)

    if args.command == "list":
        list_cmd(args)
    elif args.command == "record":
        record_cmd(args)
    else:
        raise NotImplementedError(f"subcommand {args.command}")
