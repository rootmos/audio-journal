#!/usr/bin/env python3

import argparse
import boto3
import itertools
import json
import logging
import pathlib
import hashlib
import re

from datetime import date, time, datetime

s3 = boto3.resource('s3')

logger = None
def setup_logger(level):
    l = logging.getLogger('audio-journal')
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(
        fmt='%(asctime)s:%(name)s:%(levelname)s %(message)s',
        datefmt='%Y-%m-%dT%H:%M:%S%z')
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

def parse_args():
    parser = argparse.ArgumentParser(
            description="Audio Journal command line interface",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    subparsers = parser.add_subparsers(help="sub-commands", dest='command', required=True)

    home = pathlib.Path.home()
    default_cache = home / ".cache" / "audio-journal"

    parser.add_argument("--log", default="WARN", help="set log level")
    parser.add_argument("--bucket", default="rootmos-sounds", help="S3 bucket")
    parser.add_argument("--cache", default=default_cache, help="cache")

    list_cmd = subparsers.add_parser("list", help="list sounds")
    list_cmd.add_argument("prefix", metavar="PREFIX", nargs="*")

    record = subparsers.add_parser("record", help="record track")

    return parser.parse_args()

class Cache:
    def __init__(self, path):
        self.path = path

    def _lazy_init(self):
        if not self.path.exists():
            logger.info(f"creating cache: {self.path}")
            self.path.mkdir(parents=True)

    def _path(self, parts):
        m = hashlib.sha256()
        for p in parts:
            m.update(bytes(p, "UTF-8"))
        return self.path / m.hexdigest()

    class Object:
        def __init__(self, cache, keys):
            self.cache = cache
            self.path = self.cache._path(parts=keys)
            self.keys = keys

        def exists(self):
            return self.path.exists()

        def get_string(self):
            return self.path.read_text() if self.exists() else None

        def put_string(self, s):
            self.cache._lazy_init()
            logger.debug(f"writing cached object: {self.path}")
            self.path.write_text(s)

        def get_json(self):
            s = self.get_string()
            return s and json.loads(s)

        def put_json(self, o):
            self.put_string(json.dumps(o))

        def json(self, f):
            j = self.get_json()
            if j is None:
                j = f()
                self.put_json(j)
            return j

    class NullObject:
        def exists(self):
            return None
        def get_string(self):
            return None
        def get_json(self):
            return None

    def __call__(self, *keys):
        if self.path:
            return Cache.Object(cache=self, keys=keys)
        else:
            return Cache.NullObject()

cache = None
def setup_cache(args):
    return Cache(path=args.cache)

def lenient_datetime_parse(s):
    try:
        d = date.fromisoformat(s)
        tz = datetime.now().astimezone().tzinfo
        return datetime.combine(d, time(0, 0, 0), tz)
    except ValueError:
        pass
    try:
        return datetime.fromisoformat(s)
    except ValueError:
        t = re.sub(r"^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}).\d*([+-]\d{2}:\d{2})", r"\1\2", s)
        return datetime.fromisoformat(t)

class Sound:
    def __init__(self, title, artist, composer, length, url, sha1, datetime):
        self.title = title
        self.artist = artist
        self.composer = composer
        self.length = length
        self.url = url
        self.sha1 = sha1
        self.datetime = datetime

    def from_json(j):
        return Sound(
                title = j["title"],
                artist = j["artist"],
                composer = j["composer"],
                length = j["length"],
                url = j["url"],
                sha1 = j["sha1"],
                datetime = lenient_datetime_parse(j["date"]))

def load_sounds(args):
    b = s3.Bucket(args.bucket)

    if len(args.prefix) == 0:
        i = b.objects.all()
    else:
        i = itertools.chain(*[b.objects.filter(Prefix=p) for p in args.prefix])

    ss = set()
    for o in i:
        if not o.key.endswith(".json"):
            continue

        j = cache(b.name, o.key, o.e_tag).json(lambda: json.loads(o.get()["Body"].read()))
        s = Sound.from_json(j)
        ss.add(s)

    return ss

def list_cmd(args):
    ss = load_sounds(args)

    for s in sorted(ss, key=lambda s: s.datetime):
        print(s.url)

def record_cmd(args):
    raise NotImplementedError

if __name__ == "__main__":
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug(f"args: {args}")

    cache = setup_cache(args)

    if args.command == "list":
        list_cmd(args)
    elif args.command == "record":
        record_cmd(args)
    else:
        raise NotImplementedError(f"subcommand {args.command}")
